# # -*- coding: utf-8 -*-
# """laser holograpgy simulation .ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1reiuzj3R9uO68T5sdVkYBBKXWpqbIO-P
# """

# import numpy as np
# import matplotlib.pyplot as plt
# from PIL import Image
# from scipy.signal import find_peaks
# from scipy.fft import fft2, ifft2, fftfreq
# from scipy.special import expit

# class RefractiveIndexEstimator:
#     def __init__(self):
#         # Physical parameters
#         self.wavelength = 632.8e-9         # He-Ne laser [m]
#         self.n_medium = 1.33              # Glycerine
#         self.sphere_diameter = 25.20e-6    # [m]
#         self.sphere_radius = self.sphere_diameter / 2

#         # Simulation grid parameters
#         self.object_area_size = 100e-6      # 80×80 microns object plane
#         self.object_pixel_size = 0.2579e-6 # Calibrated resolution [m/pixel]
#         self.N = int(self.object_area_size / self.object_pixel_size)
#         if self.N % 2 != 0:
#             self.N += 1

#         # Microscope system parameters
#         self.objective_NA = 0.75           # Nikon Plan Fluor 40X/0.75
#         self.defocus_distance = 130e-6     # Effective defocus [m]

#         # Derived parameters
#         self.k = 2 * np.pi / self.wavelength
#         self.actual_field_size = self.N * self.object_pixel_size

#         print(f"Simulation grid: {self.N}×{self.N} pixels")
#         print(f"Actual field size: {self.actual_field_size*1e6:.2f}×{self.actual_field_size*1e6:.2f} μm")

#         self.setup_grids()

#     def setup_grids(self):
#         x = np.linspace(-self.actual_field_size/2, self.actual_field_size/2, self.N)
#         y = np.linspace(-self.actual_field_size/2, self.actual_field_size/2, self.N)
#         self.X, self.Y = np.meshgrid(x, y)
#         fx = fftfreq(self.N, d=self.object_pixel_size)
#         fy = fftfreq(self.N, d=self.object_pixel_size)
#         self.FX, self.FY = np.meshgrid(fx, fy)
#         self.k_perp_sq = self.FX**2 + self.FY**2

#     # --- UPDATED radial_profile method ---
#     def radial_profile(self, img, center=None, n_bins=150):
#         """Extract radial intensity profile with manual control over number of bins"""
#         y, x = np.indices(img.shape)
#         if center is None:
#             center = (img.shape[1]//2, img.shape[0]//2)
#         r = np.sqrt((x - center[0])**2 + (y - center[1])**2)
#         max_radius = np.max(r)
#         bin_edges = np.linspace(0, max_radius, n_bins + 1)
#         tbin, _ = np.histogram(r.ravel(), bins=bin_edges, weights=img.ravel())
#         nr, _ = np.histogram(r.ravel(), bins=bin_edges)
#         radialprofile = np.divide(tbin, nr, out=np.zeros_like(tbin, dtype=float), where=nr!=0)
#         bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2 * self.object_pixel_size * 1e6  # in microns
#         return radialprofile, bin_centers

#     def find_intensity_minima(self, radial_profile, r_centers, max_radius=50):
#         mask = r_centers <= max_radius
#         r_microns = r_centers[mask]
#         profile = radial_profile[mask]
#         inverted = -profile
#         peaks, _ = find_peaks(inverted, distance=3, height=-np.inf)
#         if len(peaks) > 0:
#             minima_positions = r_microns[peaks]
#             return minima_positions
#         else:
#             return np.array([])

#     #def load_experimental_image(self, filename):
#         #real_img = Image.open("FOV6 130um defocus_cropped.jpg").convert("L")
#         # real_np = np.array(real_img, dtype=np.float32)
#         # real_np /= real_np.max()
#         # return real_np

#     def create_sphere_field(self, n_sphere):
#         incident_field = np.ones((self.N, self.N), dtype=complex)
#         R_sphere = np.sqrt(self.X**2 + self.Y**2)
#         edge_width = 0.4e-6
#         mask = expit(-(R_sphere - self.sphere_radius) / edge_width)
#         thickness = 2 * np.sqrt(np.clip(self.sphere_radius**2 - R_sphere**2, 0, None))
#         thickness *= mask
#         phase_delay = self.k * (n_sphere - self.n_medium) * thickness
#         scattered_field = np.exp(1j * phase_delay) - 1
#         total_field = incident_field + scattered_field
#         return total_field

#     def simulate_imaging_system(self, n_sphere):
#         object_field = self.create_sphere_field(n_sphere)
#         k_max = self.objective_NA / self.wavelength
#         k_perp = np.sqrt(self.k_perp_sq)
#         aperture = (k_perp <= k_max).astype(complex)
#         object_spectrum = fft2(object_field)
#         filtered_spectrum = object_spectrum * aperture
#         field_after_objective = ifft2(filtered_spectrum)
#         k0_sq = (1 / self.wavelength)**2
#         kz = np.zeros_like(self.k_perp_sq, dtype=complex)
#         propagating = self.k_perp_sq <= k0_sq
#         evanescent = self.k_perp_sq > k0_sq
#         kz[propagating] = np.sqrt(k0_sq - self.k_perp_sq[propagating])
#         kz[evanescent] = 1j * np.sqrt(self.k_perp_sq[evanescent] - k0_sq)
#         H = np.exp(1j * 2 * np.pi * self.defocus_distance * kz)
#         field_ft = fft2(field_after_objective)
#         propagated_ft = field_ft * H
#         field_at_sensor = ifft2(propagated_ft)
#         intensity = np.abs(field_at_sensor)**2
#         corner_size = 20
#         corners = [
#             intensity[:corner_size, :corner_size],
#             intensity[:corner_size, -corner_size:],
#             intensity[-corner_size:, :corner_size],
#             intensity[-corner_size:, -corner_size:]
#         ]
#         background_intensity = np.mean(corners)
#         intensity_normalized = intensity / background_intensity
#         return intensity_normalized

#     def cost_function(self, n_sphere, exp_minima_positions, n_bins=300):
#         sim_intensity = self.simulate_imaging_system(n_sphere)
#         sim_radial_profile, sim_r_centers = self.radial_profile(sim_intensity, n_bins=n_bins)
#         sim_minima_positions = self.find_intensity_minima(sim_radial_profile, sim_r_centers)
#         n_minima = min(5, len(exp_minima_positions), len(sim_minima_positions))
#         if n_minima == 0:
#             return np.inf, sim_minima_positions
#         exp_first_5 = exp_minima_positions[:n_minima]
#         sim_first_5 = sim_minima_positions[:n_minima]
#         cost = np.sum((exp_first_5 - sim_first_5)**2)
#         return cost, sim_minima_positions

#     def optimize_refractive_index(self, exp_minima_positions, n_bins=300):
#         n_values = np.arange(1.4800, 1.5399, 0.0001)
#         costs = []
#         all_sim_minima = []
#         print("Optimizing refractive index...")
#         print("n_sphere | Cost")
#         print("-" * 20)
#         for i, n_sphere in enumerate(n_values):
#             cost, sim_minima = self.cost_function(n_sphere, exp_minima_positions, n_bins=n_bins)
#             costs.append(cost)
#             all_sim_minima.append(sim_minima)
#             if i % 20 == 0:
#                 print(f"{n_sphere:.3f}   | {cost:.6f}")
#         best_idx = np.argmin(costs)
#         best_n = n_values[best_idx]
#         best_cost = costs[best_idx]
#         best_sim_minima = all_sim_minima[best_idx]
#         return best_n, best_cost, best_sim_minima, n_values, costs

# # === MAIN EXECUTION ===

# N_BINS = 150  # Set your desired radial resolution here

# estimator = RefractiveIndexEstimator()

# print("1. Loading experimental image...")
# # exp_image = estimator.load_experimental_image("MS glycerine defocused 100mic fov3_cropped_left_1.jpg")

# print("2. Extracting experimental radial profile...")
# exp_radial_profile, exp_r_centers = estimator.radial_profile(exp_image, n_bins=N_BINS)

# print("3. Finding experimental intensity minima...")
# exp_minima_positions = estimator.find_intensity_minima(exp_radial_profile, exp_r_centers)

# print("4. Recording first 5 experimental minima positions...")
# exp_first_5_minima = exp_minima_positions[:5]
# # exp_first_5_minima_1 = exp_minima_positions[:3]
# # exp_first_5_minima_2 = exp_minima_positions[4:6]
# # exp_first_5_minima = np.concatenate((exp_first_5_minima_1, exp_first_5_minima_2))
# print(f"Experimental minima positions (first 5): {exp_first_5_minima}")

# print("\n5-10. Optimizing refractive index...")
# best_n, best_cost, best_sim_minima, all_n_values, all_costs = estimator.optimize_refractive_index(exp_first_5_minima, n_bins=N_BINS)

# print(f"\n=== OPTIMIZATION RESULTS ===")
# print(f"Best refractive index: {best_n:.3f}")
# print(f"Minimum cost: {best_cost:.6f}")
# print(f"Best simulated minima positions (first 5): {best_sim_minima[:5]}")

# print("\n11. Generating final results...")

# best_sim_intensity = estimator.simulate_imaging_system(best_n)
# best_sim_radial_profile, best_sim_r_centers = estimator.radial_profile(best_sim_intensity, n_bins=N_BINS)

# fig = plt.figure(figsize=(16, 12))

# ax1 = plt.subplot(2, 4, 1)
# plt.imshow(exp_image, cmap='gray')
# plt.title('Experimental Image')
# plt.xlabel('x [pixels]')
# plt.ylabel('y [pixels]')
# plt.colorbar(label='Intensity')

# ax2 = plt.subplot(2, 4, 2)
# extent_um = [-estimator.actual_field_size/2*1e6, estimator.actual_field_size/2*1e6,
#              -estimator.actual_field_size/2*1e6, estimator.actual_field_size/2*1e6]
# plt.imshow(best_sim_intensity, cmap='gray', extent=extent_um)
# plt.title(f'Simulated Image (n={best_n:.3f})')
# plt.xlabel('x [μm]')
# plt.ylabel('y [μm]')
# plt.colorbar(label='Normalized Intensity')
# #plt.savefig('best_sim_intensity.jpg')

# # --- UPDATED: Use bin centers for x-axis in all radial profile plots ---
# ax3 = plt.subplot(2, 4, 3)
# plt.plot(exp_r_centers, exp_radial_profile, 'b-', label='Experimental')
# plt.scatter(exp_first_5_minima, exp_radial_profile[np.searchsorted(exp_r_centers, exp_first_5_minima)],
#            color='red', s=50, label='First 5 Minima')
# plt.xlabel('Radial Position [μm]')
# plt.ylabel('Normalized Intensity')
# plt.title('Experimental Radial Profile')
# plt.legend()
# plt.grid(True, alpha=0.3)
# plt.xlim(0, 40)

# ax4 = plt.subplot(2, 4, 4)
# plt.plot(best_sim_r_centers, best_sim_radial_profile, 'g-', label='Simulated')
# plt.scatter(best_sim_minima[:5], best_sim_radial_profile[np.searchsorted(best_sim_r_centers, best_sim_minima[:5])],
#            color='orange', s=50, label='First 5 Minima')
# plt.xlabel('Radial Position [μm]')
# plt.ylabel('Normalized Intensity')
# plt.title('Simulated Radial Profile')
# plt.legend()
# plt.grid(True, alpha=0.3)
# plt.xlim(0, 40)
# plt.ylim(0, 2)

# ax5 = plt.subplot(2, 4, 5)
# plt.plot(exp_r_centers, exp_radial_profile, 'b-', label='Experimental', linewidth=2)
# plt.plot(best_sim_r_centers, best_sim_radial_profile, 'g--', label=f'Simulated (n={best_n:.3f})', linewidth=2)
# plt.scatter(exp_first_5_minima, exp_radial_profile[np.searchsorted(exp_r_centers, exp_first_5_minima)],
#            color='red', s=50, label='Exp. Minima')
# plt.scatter(best_sim_minima[:5], best_sim_radial_profile[np.searchsorted(best_sim_r_centers, best_sim_minima[:5])],
#            color='orange', s=50, label='Sim. Minima')
# plt.xlabel('Radial Position [μm]')
# plt.ylabel('Normalized Intensity')
# plt.title('Profile Comparison')
# plt.legend()
# plt.grid(True, alpha=0.3)
# plt.xlim(0, 30)
# plt.ylim(0, 2)

# ax6 = plt.subplot(2, 4, 6)
# plt.plot(all_n_values, all_costs, 'r-', linewidth=2)
# plt.scatter(best_n, best_cost, color='red', s=100, zorder=5)
# plt.xlabel('Refractive Index')
# plt.ylabel('Cost Function')
# plt.title('Optimization Curve')
# plt.grid(True, alpha=0.3)
# plt.annotate(f'Best: n={best_n:.3f}', xy=(best_n, best_cost),
#             xytext=(best_n+0.05, best_cost+best_cost*0.1),
#             arrowprops=dict(arrowstyle='->', color='red'))

# ax7 = plt.subplot(2, 4, 7)
# x_pos = np.arange(len(exp_first_5_minima))
# width = 0.35
# plt.bar(x_pos - width/2, exp_first_5_minima, width, label='Experimental', alpha=0.7)
# plt.bar(x_pos + width/2, best_sim_minima[:5], width, label='Simulated', alpha=0.7)
# plt.xlabel('Minima Index')
# plt.ylabel('Radial Position [μm]')
# plt.title('Minima Positions Comparison')
# plt.legend()
# plt.xticks(x_pos, [f'Min {i+1}' for i in range(len(exp_first_5_minima))])

# ax8 = plt.subplot(2, 4, 8)
# errors = np.abs(exp_first_5_minima - best_sim_minima[:5])
# plt.bar(range(len(errors)), errors, alpha=0.7, color='purple')
# plt.xlabel('Minima Index')
# plt.ylabel('Absolute Error [μm]')
# plt.title('Position Errors')
# plt.xticks(range(len(errors)), [f'Min {i+1}' for i in range(len(errors))])

# plt.tight_layout()
# plt.show()

# fig1 = plt.figure(figsize=(12, 8))
# extent_um = [-estimator.actual_field_size/2*1e6, estimator.actual_field_size/2*1e6,
#              -estimator.actual_field_size/2*1e6, estimator.actual_field_size/2*1e6]
# #plt.imshow(best_sim_intensity, cmap='gray', extent=extent_um)
# plt.imshow(best_sim_intensity, cmap='gray', extent=extent_um, vmin=0, vmax=2)
# plt.title(f'Simulated Image (n={best_n:.3f})')
# plt.xlabel('x [μm]')
# plt.ylabel('y [μm]')
# plt.colorbar(label='Normalized Intensity')
# plt.savefig('best_sim_intensity.jpg')

# fig2 = plt.figure(figsize=(12, 8))
# plt.plot(exp_r_centers, exp_radial_profile, 'b-', label='Experimental', linewidth=2)
# plt.plot(best_sim_r_centers, best_sim_radial_profile, 'g--', label=f'Simulated (n={best_n:.3f})', linewidth=2)
# plt.scatter(exp_first_5_minima, exp_radial_profile[np.searchsorted(exp_r_centers, exp_first_5_minima)],
#            color='red', s=50, label='Exp. Minima')
# plt.scatter(best_sim_minima[:5], best_sim_radial_profile[np.searchsorted(best_sim_r_centers, best_sim_minima[:5])],
#            color='orange', s=50, label='Sim. Minima')
# plt.xlabel('Radial Position [μm]')
# plt.ylabel('Normalized Intensity')
# plt.title('Profile Comparison')
# plt.legend()
# plt.grid(True, alpha=0.3)
# plt.xlim(0, 30)
# plt.ylim(0, 2)
# plt.savefig('profile_comparison.jpg')

# print(f"\n=== FINAL SUMMARY ===")
# print(f"Sphere diameter: {estimator.sphere_diameter*1e6:.2f} μm")
# print(f"Optimized refractive index: {best_n:.3f}")
# print(f"Final cost: {best_cost:.6f}")
# print(f"RMS error in minima positions: {np.sqrt(np.mean((exp_first_5_minima - best_sim_minima[:5])**2)):.4f} μm")

# laser_holography_simulation.py



# import numpy as np
# from PIL import Image
# from scipy.signal import find_peaks
# from scipy.fft import fft2, ifft2, fftfreq
# from scipy.special import expit

# class RefractiveIndexEstimator:
#     def __init__(self):
#         self.wavelength = 632.8e-9
#         self.n_medium = 1.33
#         self.sphere_diameter = 25.20e-6
#         self.sphere_radius = self.sphere_diameter / 2

#         self.object_area_size = 100e-6
#         self.object_pixel_size = 0.2579e-6
#         self.N = int(self.object_area_size / self.object_pixel_size)
#         if self.N % 2 != 0:
#             self.N += 1

#         self.objective_NA = 0.75
#         self.defocus_distance = 130e-6

#         self.k = 2 * np.pi / self.wavelength
#         self.actual_field_size = self.N * self.object_pixel_size

#         self.setup_grids()

#     def setup_grids(self):
#         x = np.linspace(-self.actual_field_size / 2, self.actual_field_size / 2, self.N)
#         y = np.linspace(-self.actual_field_size / 2, self.actual_field_size / 2, self.N)
#         self.X, self.Y = np.meshgrid(x, y)
#         fx = fftfreq(self.N, d=self.object_pixel_size)
#         fy = fftfreq(self.N, d=self.object_pixel_size)
#         self.FX, self.FY = np.meshgrid(fx, fy)
#         self.k_perp_sq = self.FX**2 + self.FY**2

#     def radial_profile(self, img, center=None, n_bins=150):
#         y, x = np.indices(img.shape)
#         if center is None:
#             center = (img.shape[1] // 2, img.shape[0] // 2)
#         r = np.sqrt((x - center[0])**2 + (y - center[1])**2)
#         bin_edges = np.linspace(0, np.max(r), n_bins + 1)
#         tbin, _ = np.histogram(r.ravel(), bins=bin_edges, weights=img.ravel())
#         nr, _ = np.histogram(r.ravel(), bins=bin_edges)
#         radialprofile = np.divide(tbin, nr, out=np.zeros_like(tbin, dtype=float), where=nr != 0)
#         bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2 * self.object_pixel_size * 1e6
#         return radialprofile, bin_centers

#     def find_intensity_minima(self, radial_profile, r_centers, max_radius=50):
#         mask = r_centers <= max_radius
#         r_microns = r_centers[mask]
#         profile = radial_profile[mask]
#         inverted = -profile
#         peaks, _ = find_peaks(inverted, distance=3, height=-np.inf)
#         return r_microns[peaks] if len(peaks) > 0 else np.array([])

#     def load_experimental_image(self, uploaded_file):
#         img = Image.open(uploaded_file).convert("L")
#         img = img.resize((self.N, self.N))  # resize for simulation grid match
#         arr = np.array(img, dtype=np.float32)
#         arr /= arr.max()
#         return arr

#     def create_sphere_field(self, n_sphere):
#         incident_field = np.ones((self.N, self.N), dtype=complex)
#         R_sphere = np.sqrt(self.X**2 + self.Y**2)
#         edge_width = 0.4e-6
#         mask = expit(-(R_sphere - self.sphere_radius) / edge_width)
#         thickness = 2 * np.sqrt(np.clip(self.sphere_radius**2 - R_sphere**2, 0, None)) * mask
#         phase_delay = self.k * (n_sphere - self.n_medium) * thickness
#         scattered_field = np.exp(1j * phase_delay) - 1
#         return incident_field + scattered_field

#     def simulate_imaging_system(self, n_sphere):
#         object_field = self.create_sphere_field(n_sphere)
#         k_max = self.objective_NA / self.wavelength
#         k_perp = np.sqrt(self.k_perp_sq)
#         aperture = (k_perp <= k_max).astype(complex)
#         object_spectrum = fft2(object_field)
#         filtered_spectrum = object_spectrum * aperture
#         field_after_objective = ifft2(filtered_spectrum)

#         k0_sq = (1 / self.wavelength)**2
#         kz = np.zeros_like(self.k_perp_sq, dtype=complex)
#         propagating = self.k_perp_sq <= k0_sq
#         evanescent = ~propagating
#         kz[propagating] = np.sqrt(k0_sq - self.k_perp_sq[propagating])
#         kz[evanescent] = 1j * np.sqrt(self.k_perp_sq[evanescent] - k0_sq)

#         H = np.exp(1j * 2 * np.pi * self.defocus_distance * kz)
#         field_ft = fft2(field_after_objective)
#         propagated_ft = field_ft * H
#         field_at_sensor = ifft2(propagated_ft)
#         intensity = np.abs(field_at_sensor)**2

#         corner_size = 20
#         background_intensity = np.mean([
#             intensity[:corner_size, :corner_size],
#             intensity[:corner_size, -corner_size:],
#             intensity[-corner_size:, :corner_size],
#             intensity[-corner_size:, -corner_size:]
#         ])
#         return intensity / background_intensity

#     def cost_function(self, n_sphere, exp_minima_positions, n_bins=300):
#         sim_intensity = self.simulate_imaging_system(n_sphere)
#         sim_radial_profile, sim_r_centers = self.radial_profile(sim_intensity, n_bins=n_bins)
#         sim_minima_positions = self.find_intensity_minima(sim_radial_profile, sim_r_centers)
#         n_minima = min(5, len(exp_minima_positions), len(sim_minima_positions))
#         if n_minima == 0:
#             return np.inf, sim_minima_positions
#         cost = np.sum((exp_minima_positions[:n_minima] - sim_minima_positions[:n_minima])**2)
#         return cost, sim_minima_positions

#     def optimize_refractive_index(self, exp_minima_positions, n_bins=300):
#         n_values = np.arange(1.4800, 1.5400, 0.0002)
#         costs = []
#         all_sim_minima = []
#         for n in n_values:
#             cost, sim_minima = self.cost_function(n, exp_minima_positions, n_bins=n_bins)
#             costs.append(cost)
#             all_sim_minima.append(sim_minima)
#         best_idx = np.argmin(costs)
#         return n_values[best_idx], costs[best_idx], all_sim_minima[best_idx], n_values, costs




# import numpy as np
# from PIL import Image
# from scipy.signal import find_peaks
# from scipy.fft import fft2, ifft2, fftfreq
# from scipy.special import expit

# class RefractiveIndexEstimator:
#     def __init__(self):
#         self.wavelength = 632.8e-9
#         self.n_medium = 1.33
#         self.sphere_diameter = 25.20e-6
#         self.sphere_radius = self.sphere_diameter / 2

#         self.object_area_size = 100e-6
#         self.object_pixel_size = 0.2579e-6
#         self.N = int(self.object_area_size / self.object_pixel_size)
#         if self.N % 2 != 0:
#             self.N += 1

#         self.objective_NA = 0.75
#         self.defocus_distance = 130e-6

#         self.k = 2 * np.pi / self.wavelength
#         self.actual_field_size = self.N * self.object_pixel_size

#         self.setup_grids()

#     def setup_grids(self):
#         x = np.linspace(-self.actual_field_size / 2, self.actual_field_size / 2, self.N)
#         y = np.linspace(-self.actual_field_size / 2, self.actual_field_size / 2, self.N)
#         self.X, self.Y = np.meshgrid(x, y)
#         fx = fftfreq(self.N, d=self.object_pixel_size)
#         fy = fftfreq(self.N, d=self.object_pixel_size)
#         self.FX, self.FY = np.meshgrid(fx, fy)
#         self.k_perp_sq = self.FX**2 + self.FY**2

#     def radial_profile(self, img, center=None, n_bins=150):
#         y, x = np.indices(img.shape)
#         if center is None:
#             center = (img.shape[1] // 2, img.shape[0] // 2)
#         r = np.sqrt((x - center[0])**2 + (y - center[1])**2)
#         bin_edges = np.linspace(0, np.max(r), n_bins + 1)
#         tbin, _ = np.histogram(r.ravel(), bins=bin_edges, weights=img.ravel())
#         nr, _ = np.histogram(r.ravel(), bins=bin_edges)
#         radialprofile = np.divide(tbin, nr, out=np.zeros_like(tbin, dtype=float), where=nr != 0)
#         bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2 * self.object_pixel_size * 1e6
#         return radialprofile, bin_centers

#     def find_intensity_minima(self, radial_profile, r_centers, max_radius=50):
#         mask = r_centers <= max_radius
#         r_microns = r_centers[mask]
#         profile = radial_profile[mask]
#         inverted = -profile
#         peaks, _ = find_peaks(inverted, distance=3, height=-np.inf)
#         return r_microns[peaks] if len(peaks) > 0 else np.array([])

#     def load_experimental_image(self, uploaded_file):
#         img = Image.open(uploaded_file).convert("L")
#         img = img.resize((self.N, self.N))  # resize for simulation grid match
#         arr = np.array(img, dtype=np.float32)
#         arr /= arr.max()
#         return arr

#     def create_sphere_field(self, n_sphere):
#         incident_field = np.ones((self.N, self.N), dtype=complex)
#         R_sphere = np.sqrt(self.X**2 + self.Y**2)
#         edge_width = 0.4e-6
#         mask = expit(-(R_sphere - self.sphere_radius) / edge_width)
#         thickness = 2 * np.sqrt(np.clip(self.sphere_radius**2 - R_sphere**2, 0, None)) * mask
#         phase_delay = self.k * (n_sphere - self.n_medium) * thickness
#         scattered_field = np.exp(1j * phase_delay) - 1
#         return incident_field + scattered_field

#     def simulate_imaging_system(self, n_sphere):
#         object_field = self.create_sphere_field(n_sphere)
#         k_max = self.objective_NA / self.wavelength
#         k_perp = np.sqrt(self.k_perp_sq)
#         aperture = (k_perp <= k_max).astype(complex)
#         object_spectrum = fft2(object_field)
#         filtered_spectrum = object_spectrum * aperture
#         field_after_objective = ifft2(filtered_spectrum)

#         k0_sq = (1 / self.wavelength)**2
#         kz = np.zeros_like(self.k_perp_sq, dtype=complex)
#         propagating = self.k_perp_sq <= k0_sq
#         evanescent = ~propagating
#         kz[propagating] = np.sqrt(k0_sq - self.k_perp_sq[propagating])
#         kz[evanescent] = 1j * np.sqrt(self.k_perp_sq[evanescent] - k0_sq)

#         H = np.exp(1j * 2 * np.pi * self.defocus_distance * kz)
#         field_ft = fft2(field_after_objective)
#         propagated_ft = field_ft * H
#         field_at_sensor = ifft2(propagated_ft)
#         intensity = np.abs(field_at_sensor)**2

#         corner_size = 20
#         background_intensity = np.mean([
#             intensity[:corner_size, :corner_size],
#             intensity[:corner_size, -corner_size:],
#             intensity[-corner_size:, :corner_size],
#             intensity[-corner_size:, -corner_size:]
#         ])
#         return intensity / background_intensity

#     def cost_function(self, n_sphere, exp_minima_positions, n_bins=300):
#         sim_intensity = self.simulate_imaging_system(n_sphere)
#         sim_radial_profile, sim_r_centers = self.radial_profile(sim_intensity, n_bins=n_bins)
#         sim_minima_positions = self.find_intensity_minima(sim_radial_profile, sim_r_centers)
#         n_minima = min(5, len(exp_minima_positions), len(sim_minima_positions))
#         if n_minima == 0:
#             return np.inf, sim_minima_positions
#         cost = np.sum((exp_minima_positions[:n_minima] - sim_minima_positions[:n_minima])**2)
#         return cost, sim_minima_positions

#     def optimize_refractive_index(self, exp_minima_positions, n_bins=300):
#         n_values = np.arange(1.4800, 1.5400, 0.0002)
#         costs = []
#         all_sim_minima = []
#         for n in n_values:
#             cost, sim_minima = self.cost_function(n, exp_minima_positions, n_bins=n_bins)
#             costs.append(cost)
#             all_sim_minima.append(sim_minima)
#         best_idx = np.argmin(costs)
#         return n_values[best_idx], costs[best_idx], all_sim_minima[best_idx], n_values, costs





import numpy as np
from PIL import Image
from scipy.signal import find_peaks
from scipy.fft import fft2, ifft2, fftfreq
from scipy.special import expit

class RefractiveIndexEstimator:
    def __init__(self, wavelength=632.8e-9, n_medium=1.33, sphere_diameter=25.20e-6,
                 object_area_size=100e-6, object_pixel_size=0.2579e-6, objective_NA=0.75,
                 defocus_distance=130e-6):
        self.wavelength = wavelength
        self.n_medium = n_medium
        self.sphere_diameter = sphere_diameter
        self.sphere_radius = self.sphere_diameter / 2

        self.object_area_size = object_area_size
        self.object_pixel_size = object_pixel_size
        self.N = int(self.object_area_size / self.object_pixel_size)
        if self.N % 2 != 0:
            self.N += 1

        self.objective_NA = objective_NA
        self.defocus_distance = defocus_distance

        self.k = 2 * np.pi / self.wavelength
        self.actual_field_size = self.N * self.object_pixel_size

        self.setup_grids()

    def setup_grids(self):
        x = np.linspace(-self.actual_field_size / 2, self.actual_field_size / 2, self.N)
        y = np.linspace(-self.actual_field_size / 2, self.actual_field_size / 2, self.N)
        self.X, self.Y = np.meshgrid(x, y)
        fx = fftfreq(self.N, d=self.object_pixel_size)
        fy = fftfreq(self.N, d=self.object_pixel_size)
        self.FX, self.FY = np.meshgrid(fx, fy)
        self.k_perp_sq = self.FX**2 + self.FY**2

    def radial_profile(self, img, center=None, n_bins=150):
        y, x = np.indices(img.shape)
        if center is None:
            center = (img.shape[1] // 2, img.shape[0] // 2)
        r = np.sqrt((x - center[0])**2 + (y - center[1])**2)
        bin_edges = np.linspace(0, np.max(r), n_bins + 1)
        tbin, _ = np.histogram(r.ravel(), bins=bin_edges, weights=img.ravel())
        nr, _ = np.histogram(r.ravel(), bins=bin_edges)
        radialprofile = np.divide(tbin, nr, out=np.zeros_like(tbin, dtype=float), where=nr != 0)
        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2 * self.object_pixel_size * 1e6
        return radialprofile, bin_centers

    def find_intensity_minima(self, radial_profile, r_centers, max_radius=50):
        mask = r_centers <= max_radius
        r_microns = r_centers[mask]
        profile = radial_profile[mask]
        inverted = -profile
        peaks, _ = find_peaks(inverted, distance=3, height=-np.inf)
        return r_microns[peaks] if len(peaks) > 0 else np.array([])

    def load_experimental_image(self, uploaded_file):
        img = Image.open(uploaded_file).convert("L")
        img = img.resize((self.N, self.N))
        arr = np.array(img, dtype=np.float32)
        arr /= arr.max()
        return arr

    def create_sphere_field(self, n_sphere):
        incident_field = np.ones((self.N, self.N), dtype=complex)
        R_sphere = np.sqrt(self.X**2 + self.Y**2)
        edge_width = 0.4e-6
        mask = expit(-(R_sphere - self.sphere_radius) / edge_width)
        thickness = 2 * np.sqrt(np.clip(self.sphere_radius**2 - R_sphere**2, 0, None)) * mask
        phase_delay = self.k * (n_sphere - self.n_medium) * thickness
        scattered_field = np.exp(1j * phase_delay) - 1
        return incident_field + scattered_field

    def simulate_imaging_system(self, n_sphere):
        object_field = self.create_sphere_field(n_sphere)
        k_max = self.objective_NA / self.wavelength
        k_perp = np.sqrt(self.k_perp_sq)
        aperture = (k_perp <= k_max).astype(complex)
        object_spectrum = fft2(object_field)
        filtered_spectrum = object_spectrum * aperture
        field_after_objective = ifft2(filtered_spectrum)

        k0_sq = (1 / self.wavelength)**2
        kz = np.zeros_like(self.k_perp_sq, dtype=complex)
        propagating = self.k_perp_sq <= k0_sq
        evanescent = ~propagating
        kz[propagating] = np.sqrt(k0_sq - self.k_perp_sq[propagating])
        kz[evanescent] = 1j * np.sqrt(self.k_perp_sq[evanescent] - k0_sq)

        H = np.exp(1j * 2 * np.pi * self.defocus_distance * kz)
        field_ft = fft2(field_after_objective)
        propagated_ft = field_ft * H
        field_at_sensor = ifft2(propagated_ft)
        intensity = np.abs(field_at_sensor)**2

        corner_size = 20
        background_intensity = np.mean([
            intensity[:corner_size, :corner_size],
            intensity[:corner_size, -corner_size:],
            intensity[-corner_size:, :corner_size],
            intensity[-corner_size:, -corner_size:]
        ])
        return intensity / background_intensity

    def cost_function(self, n_sphere, exp_minima_positions, n_bins=300):
        sim_intensity = self.simulate_imaging_system(n_sphere)
        sim_radial_profile, sim_r_centers = self.radial_profile(sim_intensity, n_bins=n_bins)
        sim_minima_positions = self.find_intensity_minima(sim_radial_profile, sim_r_centers)
        n_minima = min(5, len(exp_minima_positions), len(sim_minima_positions))
        if n_minima == 0:
            return np.inf, sim_minima_positions
        cost = np.sum((exp_minima_positions[:n_minima] - sim_minima_positions[:n_minima])**2)
        return cost, sim_minima_positions

    # def optimize_refractive_index(self, exp_minima_positions, n_bins=300):
    #     n_values = np.arange(1.4800, 1.5400, 0.0002)
    #     costs = []
    #     all_sim_minima = []
    #     for n in n_values:
    #         cost, sim_minima = self.cost_function(n, exp_minima_positions, n_bins=n_bins)
    #         costs.append(cost)
    #         all_sim_minima.append(sim_minima)
    #     best_idx = np.argmin(costs)
    #     return n_values[best_idx], costs[best_idx], all_sim_minima[best_idx], n_values, costs

    def optimize_refractive_index(self, exp_minima_positions, n_bins=300):
        n_values = np.arange(1.4800, 1.5399, 0.0001)
        costs = []
        all_sim_minima = []
        # print("Optimizing refractive index...")
        # print("n_sphere | Cost")
        # print("-" * 20)
        for i, n_sphere in enumerate(n_values):
            cost, sim_minima = self.cost_function(n_sphere, exp_minima_positions, n_bins=n_bins)
            costs.append(cost)
            all_sim_minima.append(sim_minima)
            # if i % 20 == 0:
            #     print(f"{n_sphere:.3f}   | {cost:.6f}")
        best_idx = np.argmin(costs)
        best_n = n_values[best_idx]
        best_cost = costs[best_idx]
        best_sim_minima = all_sim_minima[best_idx]
        return best_n, best_cost, best_sim_minima, n_values, costs
